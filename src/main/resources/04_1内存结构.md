	https://infoq.cn/article/Java-permgen-Removed


JDK自带的性能分析工具的完整分析
	命令行查看JVM信息
		jmap -clstats PID: 查看当前Java进程的类加载器信息
		jmap -heap PID: 堆的信息
		jstat -gc PID: 打印元空间的内存使用信息(MC表示元空间大小, MU表示已经使用的元空间大小)
		jstack pid: 获取指定线程的堆栈信息
		jhat: 会开启一个指定的端口, 从而可以在浏览器中利用OQL语法来分析heap dump文件

		jcmd命令需要配合JVM参数[-XX:+UnlockDiagnosticVMOptions]使用
		jcmd -h: 查看jcmd命令的使用帮助
		jcmd -l(jcmd, jps -l): 查看所有的Java进程
		jcmd [pid, mainclass] help: 查看对该Java进程可使用的命令参数
		jcmd [pid, mainclass] help command: 查看对应的命令可加入的选项
			jcmd pid GC.class_histogram: 查看对应的Java进程的类的统计信息
			jcmd pid GC.class_stats: 查看对应的Java进程的已经加载的类的信息
			jcmd pid GC.heap_dump 文件名.hprof: 将此时的堆信息转储成一个文件(可用jvisualvm查看)
			jcmd pid VM.flags: 查看JVM的启动参数
			jcmd pid VM.uptime: 查看JVM的启动时长
			jcmd pid Thread.print: 查看线程的堆栈信息
			jcmd pid PerfCounter.print: 查看JVM性能相关的信息
			jcmd pid VM.command_line: 查看JVM启动的命令行参数

	图形化工具:
		jvisualvm
		jconsole
		jmc: 相比于前两个更加的强大, 界面更加的美观
	









Java的内存结构:
  虚拟机栈(线程独有): 里面存放的是一个个栈帧, 栈帧中保存了方法的局部变量表, 方法的返回地址, 动态链接信息以及
            操作数栈等, 一个方法的执行过程, 就是这个方法对于栈帧的入栈出栈过程 
  程序计数器(PC)(线程独有): 表示当前执行的是第几个字节码指令, 下一个应该执行的是第几个字节码指令
  本地方法栈: 主要用于处理本地方法(native)
  堆(Heap)(所有线程共享的一块区域): JVM管理的最大一块空间, 是GC的主要工作区域, 堆中主要放置对象, 
																	而对于变量来说, 如Object obj = new Object(),
            在堆中存放的就是new出来的Object对象, 而这个obj就是局部变量, 局部变量的值是指向堆中对象
            Object的指针, 关于局部变量的值指向有两种情况
            情况一: obj指向堆中的一个句柄, 这个句柄中存放了两个指针信息, 一个指针指向的是真正的
                   Object对象, 另一个指针指向的是方法区中关于该对象的Class类信息, 也叫元数据
            情况二: obj指向堆中的一个位置, 这个位置中存放了真正的Object对象以及一个指针指向方法区
                    中的元数据(oracle的Hotspot虚拟机采用该方式)
            注意: 与堆相关的一个重要的概念就是垃圾收集器, 现在几乎所有的的垃圾收集器都是采用的分代
                  收集算法, 所以堆空间也基于这一点进行了相应的划分: 新生代与老年代, Eden空间,
                  From survivor空间与To Survivor空间

  方法区: 存储元信息, 跟永久代(表示几乎不会被垃圾回收机制回收的数据)的特性类似, 在JDK1.8以后废弃了
          永久代,改为了元空间
  运行时常量池: 属于方法区的一部分, 主要保存的是运行时的常量池
  直接内存: 不属于JVM管理, 由操作系统管理, 与Java NIO密切相关, Java通过堆上的DirectByteBuffer来
           操作直接内存



关于Java创建对象的三个步骤:
		1. 在堆内存中创建对象的实例(字节码指令: new)
		2. 为对象的实例成员变量赋初值(字节码上可以看到执行了<init>方法)(字节码指令: invokespecial)
		3. 将对象的引用返回(字节码指令: astore_1)

为对象在堆内存开辟空间的两种方式:
	指针碰撞(前提是堆中的空间通过一个指针进行分割, 一侧是已经被占用的空间, 另一侧是未被占用的空间)
	空闲列表(前提是堆内存空间中已被使用与未被使用的空间是交织在一起的, 这时虚拟机就要通过一个列表来记录
					哪些空间是可以使用的, 哪些空间是已经被使用的, 接下来找出可以容纳下新创建对象的且未被使用的
					空间, 在此空间存放该对象, 同时修改列表上内存的记录)

对象在内存中的布局:
	1. 对象头(描述对象的一些信息, 比如对象对应的哈希码)
	2. 实例数据(即我们在一个类中所声明的各项信息)
	3. 对象填充(起到了占位符的作用, 假设一个对象需要占用1M, 那么当一个对象不够这么大的时候, 就利用对象填充来填补空闲的位置)






















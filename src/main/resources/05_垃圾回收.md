
JVM垃圾回收(GC)模型:
  - 垃圾判断算法
      - 引用计数算法(Reference Counting)
          给对象添加一个引用计数器, 当有一个地方引用它, 计数器加1, 当引用失效, 计数器减1, 任何时刻
          计数器为0的对象就是不可能再被使用的
           
          无法解决对象循环引用的问题


      - 根搜索算法(Root Tracing)
          在实际的生产语言中(Java、C#等), 都是使用根搜索算法判定对象是否存活

          算法的基本思路就是通过一系列的称为"GC Roots"的点作为起始向下搜索, 当一个对象到GC Roots
          没有任何引用链(Reference Chain)相连, 则证明此对象是不可用的

          在Java语言中, GC Roots包括
              - 在VM栈(栈中的本地变量)中引用
              - 方法区中的静态引用
              - JNI(即一般说的Native方法)中的引用


  - GC算法(常见)
    - 标记-清除算法(Mark-Sweep) 
        描述: 算法分为"标记"和"清除"两个阶段, 首先标记出所有需要回收的对象, 然后回收所有的需要回收
              的对象
        缺点: 
          - 效率问题, 标记和清除两个过程效率都不高, 需要扫描所有对象, 堆越大, GC越慢
          - 空间问题, 标记清理之后会产生大量不连续的内存碎片, 空间碎片太多可能会导致后序使用中无法
            找到足够的连续内存而提前触发另一次的垃圾搜集动作      


    - 标记-整理算法(Mark-Compact)
    - 复制搜集算法(Copying)
        描述: 将可用内存分为两块, 每次只使用其中的一块, 当半区内存用完了, 仅将还存活的对象复制到另
              一块上面, 然后就把原来整块内存空间一次性清理掉, 这样使得每次内存回收都是对整个半区的
              回收, 内存分配时也就不用考虑内存碎片等复杂情况, 只要移动堆顶指针, 按顺序分配内存就可
              以了, 实现简单, 运行高效
        缺点: 代价是将内存缩小为原来的一半, 代价高昂    
        具体描述:
            - 现在的商业虚拟机中都是用了这一种收集算法来回收新生代
            - 将内存分为一块较大的eden空间和两块较小的survivor空间, 每次使用eden和其中一块survivor,
              当回收时将eden和survivor还存活的对象一次性拷贝到另外一块survivor空间上, 然后清理掉
              eden和用过的survivor
            - Oracle Hotspot虚拟机默认eden和survivor的大小比例是8:1, 也就是每次只有10%的内存是"浪费"的  
        - 复制收集算法在对象存活率高的时候, 效率有所下降
        - 如果不想浪费50%的空间, 就需要有额外的空间进行分配担保用于应付半区内存中所有对象都100%存活
          的极端情况, 所以在老年代一般不能直接选用这种算法        



    - 分代算法(Generational)

  - 垃圾回收器的实现和选择

  方法区:
    - Java虚拟机规范表示可以不要求虚拟机在这区实现GC, 这区GC的"性价比"一般比较低
    - 在堆中, 尤其是在新生代, 常规应用进行依次GC一般可以回收70%-95%的空间, 而方法区的GC效率远小于此
    - 当前的商业JVM都有实现方法区的GC, 主要回收两部分内存: 废弃常量与无用类
    - 在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的
      场景都需要JVM具备类卸载的支持以保证方法区不会溢出

  方法区类回收需要满足三个条件:
    - 该类所有的实例都已经被GC, 也就是JVM中不存在该Class的任何实例 
    - 加载该类的ClassLoader已经被GC
    - 该类对应的java.lang.Class对象没有在任何地方被引用, 如不能在任何地方通过反射访问该类的方法



循环引用是什么????

















